package event

import (
	"bytes"
	"encoding/json"
	//"fmt"
	//	"log"
	"github.com/asaskevich/govalidator"
	"net/http"
	"strconv"
	"strings"
)

const BEGIN_TOKENS = 40
const MAX_TOKENS = 1000
const MAX_DIFF_TOKENS = 100

type Payload struct {
	Text     string `json:"text"`
	Username string `json:"username"`
	Gateway  string `json:"gateway"`
}

type Event struct {
	Text      string      `json:"text"`
	Channel   string      `json:"channel"`
	Username  string      `json:"username"`
	Userid    string      `json:"userid"`
	Avatar    string      `json:"avatar"`
	Account   string      `json:"account"`
	Event     string      `json:"event"`
	Protocol  string      `json:"protocol"`
	Gateway   string      `json:"gateway"`
	Timestamp string      `json:"timestamp"`
	ID        string      `json:"id"`
	Extra     interface{} `json:"Extra"`
}

func SendMessage(username string, text string, gateway string) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	data := Payload{
		Text:     text,
		Username: username,
		Gateway:  gateway,
	}

	//fmt.Printf("Message from %s %s: %s\n", data.Gateway, data.Username, data.Text)

	payloadBytes, err := json.Marshal(data)
	if err != nil {
		// handle err
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "http://localhost:4242/api/message", body)
	if err != nil {
		// handle err
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

}

func Help(username string, gateway string) {
	message := "Available commands: !help !balance !add !sub"
	SendMessage(username, message, gateway)
}

func Balance(username string, gateway string, tokens *int) {
	message := "Current balance: " + strconv.Itoa(*tokens)
	SendMessage(username, message, gateway)
}

func Add(username string, message string, gateway string, balance *int) {
	endpoints := map[string]string{
		"peets":     "starbucks",
		"starbucks": "peets",
	}

	m1 := ""
	if !GotTwoArguments(message) {
		m1 = "(need 2 args) Usage: add <num>"
		SendMessage(username, m1, gateway)
		return
	}
	n1 := strings.Split(message, " ")
	numString := n1[1]
	if !IsNum(numString) {
		m1 = "Input not number.  Usage: add <num>"
		SendMessage(username, m1, gateway)
		return
	}
	diff, _ := strconv.Atoi(numString)
	if diff < 1 {
		m1 = "Usage: amount to add must be 1 or more"
		SendMessage(username, m1, gateway)
		return
	}
	if diff > MAX_DIFF_TOKENS {
		m1 = "Usage: amount to add must be " + strconv.Itoa(MAX_DIFF_TOKENS) + " or less"
		SendMessage(username, m1, gateway)
		return
	}
	if diff+*balance > MAX_TOKENS {
		m1 = "Maximum balance of tokens is " + strconv.Itoa(MAX_TOKENS)
		SendMessage(username, m1, gateway)
		return
	}

	unit := " token"
	if diff > 1 {
		unit = " tokens"
	}

	*balance = *balance + diff
	m1 = "new balance: " + strconv.Itoa(*balance)
	SendMessage(username, m1, gateway)
	m2 := username + " has deposited " + strconv.Itoa(diff) + unit
	SendMessage(username, m2, endpoints[gateway])

	return

}

func Sub(username string, message string, gateway string, balance *int) {

	endpoints := map[string]string{
		"peets":     "starbucks",
		"starbucks": "peets",
	}

	m1 := ""
	if !GotTwoArguments(message) {
		m1 = "(need 2 args) Usage: add <num>"
		SendMessage(username, m1, gateway)
		return
	}
	n1 := strings.Split(message, " ")
	numString := n1[1]
	if !IsNum(numString) {
		m1 = "Input not number.  Usage: add <num>"
		SendMessage(username, m1, gateway)
		return
	}
	diff, _ := strconv.Atoi(numString)
	if diff < 1 {
		m1 = "Usage: amount to add must be 1 or more"
		SendMessage(username, m1, gateway)
		return
	}
	if diff > MAX_DIFF_TOKENS {
		m1 = "Usage: amount to withdraw must be " + strconv.Itoa(MAX_DIFF_TOKENS) + " or less"
		SendMessage(username, m1, gateway)
		return
	}
	if *balance-diff < 0 {
		m1 = "Minimum balance of tokens is 0"
		SendMessage(username, m1, gateway)
		return
	}

	unit := " token"
	if diff > 1 {
		unit = " tokens"
	}
	*balance = *balance - diff
	m1 = "new balance: " + strconv.Itoa(*balance)
	SendMessage(username, m1, gateway)
	m2 := username + " has withdrawn " + strconv.Itoa(diff) + unit
	SendMessage(username, m2, endpoints[gateway])
	return
}

func GotTwoArguments(message string) bool {
	input := strings.Split(message, " ")
	if len(input) == 2 {
		return true
	} else {
		return false
	}
}

func IsNum(message string) bool {
	if govalidator.IsInt(message) {
		return true
	} else {
		return false
	}
}
